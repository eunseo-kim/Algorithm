# ✔백준 1918 후위표현식

- `🥇골드 3`
- `자료구조` `스택`

## 🔍[문제](https://www.acmicpc.net/problem/1918)

수식은 일반적으로 3가지 표기법으로 표현할 수 있다. 연산자가 피연산자 가운데 위치하는 중위 표기법(일반적으로 우리가 쓰는 방법이다), 연산자가 피연산자 앞에 위치하는 전위 표기법(prefix notation), 연산자가 피연산자 뒤에 위치하는 후위 표기법(postfix notation)이 그것이다. 예를 들어 중위 표기법으로 표현된 a+b는 전위 표기법으로는 +ab이고, 후위 표기법으로는 ab+가 된다.

이 문제에서 우리가 다룰 표기법은 후위 표기법이다. 후위 표기법은 위에서 말한 법과 같이 연산자가 피연산자 뒤에 위치하는 방법이다. 이 방법의 장점은 다음과 같다. 우리가 흔히 쓰는 중위 표기식 같은 경우에는 덧셈과 곱셈의 우선순위에 차이가 있어 왼쪽부터 차례로 계산할 수 없지만 후위 표기식을 사용하면 순서를 적절히 조절하여 순서를 정해줄 수 있다. 또한 같은 방법으로 괄호 등도 필요 없게 된다. 예를 들어 a+b*c를 후위 표기식으로 바꾸면 abc*+가 된다.

중위 표기식을 후위 표기식으로 바꾸는 방법을 간단히 설명하면 이렇다. 우선 주어진 중위 표기식을 연산자의 우선순위에 따라 괄호로 묶어준다. 그런 다음에 괄호 안의 연산자를 괄호의 오른쪽으로 옮겨주면 된다.

예를 들어 a+b*c는 (a+(b*c))의 식과 같게 된다. 그 다음에 안에 있는 괄호의 연산자 _를 괄호 밖으로 꺼내게 되면 (a+bc_)가 된다. 마지막으로 또 +를 괄호의 오른쪽으로 고치면 abc\*+가 되게 된다.

## ✅풀이

입력받은 중위 표현식을 앞에서부터 차례대로 접근하면서 처리한다.

이때 현재 문자가...

1. `(` 인 경우
   - 일단 스택에 넣어둔다.
2. `)` 인 경우
   - `(`를 찾을때까지 스택을 pop하고 answer에 차례대로 출력
3. `문자`인 경우
   - 바로 answer에 출력한다.
4. `연산자`인 경우
   - 현재 뽑은 연산자보다 스택에 담긴 연산자의 우선순위가 커질때까지 pop하고 answer에 차례대로 출력

> ## 💡예시로 이해해보기
>
> 주어진 중위 표현식은 `A + B * C` 이다. 앞에서부터 차례대로 문자를 처리한다.
>
> 1. `A`
>
>    바로 result에 담는다.
>
>    `result`
>
>    | A   |     |     |     |     |     |
>    | :-- | --- | --- | --- | --- | --- |
>
>    `stack`
>
>    |     |     |     |     |     |     |
>    | --- | --- | --- | --- | --- | --- |
>
> 2. `+`
>
>    스택이 비어있으니까 비교할 연산자가 없다. 그냥 스택에 담는다.
>
>    `result`
>
>    | A   |     |     |     |     |     |
>    | :-- | --- | --- | --- | --- | --- |
>
>    `stack`
>
>    | +   |     |     |     |     |     |
>    | --- | --- | --- | --- | --- | --- |
>
> 3. `B`
>
>    바로 result에 담는다.
>
>    `result`
>
>    | A   | B   |     |     |     |     |
>    | :-- | --- | --- | --- | --- | --- |
>
>    `stack`
>
>    | +   |     |     |     |     |     |
>    | --- | --- | --- | --- | --- | --- |
>
> 4. `*`
>
>    stack에서 현재 연산자보다 더 큰 연산자가 나올때까지 pop해서 result에 담는다. 그리고 현재 연산자는 다시 stack에 push
>
>    | A   | B   |     |     |     |     |
>    | :-- | --- | --- | --- | --- | --- |
>
>    `stack`
>
>    | +   | \*  |     |     |     |     |
>    | --- | --- | --- | --- | --- | --- |
>
> .
>
> 5. `C`
>
>    | A   | B   | C   |     |     |     |
>    | :-- | --- | --- | --- | --- | --- |
>
>    `stack`
>
>    | +   | \*  |     |     |     |     |
>    | --- | --- | --- | --- | --- | --- |
>
> 6. 모든 연산자를 다 탐색했으면 stack에 남아있는 문자를 차례대로 pop해서 result에 담는다.
>
>    `result`
>
>    | A   | B   | C   | \*  | +   |     |
>    | --- | --- | --- | --- | --- | --- |

## ✅코드

```python
def solution():
    infix = list(input())
    stack = []
    answer = []
    # ")"의 우선순위 > */의 우선순위 > +-의 우선순위 > "("의 우선순위
    priority = {")": 3, "*": 2, "/": 2, "+": 1, "-": 1, "(": 0}

    for t in infix:
        if t.isalpha():
            answer.append(t)
        elif t == "(":
            stack.append(t)
        elif t == ")":
            while stack and stack[-1] != "(":
                answer.append(stack.pop())
            stack.pop()
        else:
            while stack and priority[stack[-1]] >= priority[t]:
                answer.append(stack.pop())
            stack.append(t)

    while stack:
        answer.append(stack.pop())

    return "".join(answer)


print(solution())
```
